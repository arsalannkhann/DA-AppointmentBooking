# Appointment Booking Component Details

This document provides a deep dive into each individual file and module that makes up the OrionX Appointment Booking and Triage Flow.

## 1. `routers/triage.py` (The API Gateway)
**Purpose:** Acts as the main entry point for patient symptom submissions and the final response packager.
**Key Responsibilities:**
- **Rate Limiting & Auth:** Enforces API rate limits (e.g., max requests per user or tenant per hour) and extracts the authenticated `tenant_id`.
- **Pipeline Execution:** It sequentially calls the Intent Analyzer -> Orchestration Engine.
- **Action Handling:** Based on the `OrchestrationPlan` returned, it formats the final user-facing message.
  - If `ESCALATE`: It triggers the Emergency Handler to secure an immediate slot and warns the user.
  - If `CLARIFY`: It returns the list of follow-up questions generated by the Clinical Gate.
  - If `ORCHESTRATE`: It formats the scheduled slots into a readable summary (including notes on whether multiple issues can be combined into a single visit).

## 2. `core/intent_analyzer.py` (Semantic Extraction)
**Purpose:** Uses an LLM to extract structured medical data from fuzzy, unstructured user chat messages.
**Key Responsibilities:**
- **Red Flag Regex:** Before even calling the LLM, it runs lightning-fast regular expressions to catch obvious emergencies (e.g., "can't breathe", "uncontrollable bleeding") to trigger an immediate `ESCALATE`.
- **LLM Prompting:** Uses Google Gemini with strict `temperature=0.0` to parse the symptoms into boolean feature flags (e.g., `has_pain`, `swelling`, `thermal_sensitivity`). It is explicitly forbidden from diagnosing or prescribing.
- **State Merging:** If the user is answering a follow-up question (chat history), this module intelligently merges the new answers with the previously extracted state so the system doesn't develop "amnesia".
- **Safety Sanitization:** Runs a post-LLM check to ensure the LLM didn't accidentally leak diagnostic language (e.g., "you have a cavity") into the reasoning fields.

## 3. `core/clinical_gate.py` (The Digitized Junior Dentist)
**Purpose:** Acts as a strict gatekeeper to ensure no patient is routed to scheduling without a complete, medically-sound profile. 
**Key Responsibilities:**
- **Domain Inference:** Looks at the extracted features and decides which dental domain this belongs to (Endodontic, Surgical, Periodontal, Restorative, or General).
- **Completeness Profiles:** Every domain has a strict checklist. For example, Endodontics *requires* knowing how the tooth reacts to temperature (`thermal_duration`), while Surgical *requires* knowing if the patient can open their mouth fully (`trismus_status`).
- **Question Generation:** If any required fields from the checklist are missing, this module generates a precise, doctor-like question (e.g., "When exposed to hot/cold, does the pain linger for minutes?") and halts the process until answered.

## 4. `core/orchestration_engine.py` (Clinical Routing & Combiner)
**Purpose:** Translates the completed clinical data into standardized medical procedures and attempts to combine visits.
**Key Responsibilities:**
- **Deterministic Matrix (`_classify_condition`):** Converts the matrix of boolean feature flags into a distinct `condition_key` (e.g., `wisdom_extraction` or `root_canal`) using strict `if/else` logic to prevent LLM hallucination.
- **Database Resolution (`_resolve_procedure`):** Maps the abstract `condition_key` to a real `Procedure` record in the database for the specific clinic/tenant.
- **Visit Combiner:** If a patient presents with multiple issues that route to different procedures, it compares the scheduled slots to see if they share the same physical `clinic_id` and can be treated back-to-back, saving the patient a trip.
- **Enterprise Artifacts:** Generates an HL7 FHIR payload and liability-safe referral text to explain *why* the patient was routed a certain way.

## 5. `core/routing_engine.py` (Tiered Fallback Search)
**Purpose:** Ensures the patient gets an appointment even if their ideal configuration isn't available.
**Key Responsibilities:**
- **Tier 1 (Primary):** Searches for the exact specialist required at the patient's preferred clinic location.
- **Tier 2 (Alternative):** If Tier 1 fails, it drops the preferred clinic constraint and searches across *all* clinics owned by that tenant for the required specialist.
- **Tier 3 (Palliative):** If no specialists are available anywhere, it searches for a standard General Dentist who can provide emergency palliative care (pain management/antibiotics) until the specialist is available.

## 6. `core/scheduling_engine.py` (Constraint Solver)
**Purpose:** Finds actual calendar availability by solving a multi-variable grid physics problem.
**Key Responsibilities:**
- **15-Minute Grid:** Operations are calculated in strictly rounded 15-minute time blocks.
- **Resource Intersection:** To find a valid slot, it looks for an availability overlap between:
  1. A Doctor with the correct requested specialization.
  2. A Room that has the required capabilities (e.g., surgical equipment).
  3. An Anesthetist (if the user requested sedation or the procedure demands it).
- **Combo Processing:** If the procedure allows same-day consult + treatment, it calculates the exact number of contiguous 15-minute blocks needed (consult time + buffer + treatment time) and searches the overlapping masks for a large enough gap.
- **Atomic Booking (`book_appointment`):** Uses UPSERT logic on the database to prevent double-booking, locking the exact time blocks for the doctor, room, and staff simultaneously.
